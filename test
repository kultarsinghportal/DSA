trigger OpportunityTrigger on Opportunity (before insert, before update, after insert) {
    OpportunityTriggerHandler handler = new OpportunityTriggerHandler();

    if (Trigger.isBefore) {
        if (Trigger.isInsert || Trigger.isUpdate) {
            handler.beforeInsertOrUpdate(Trigger.new, Trigger.isInsert);
        }
    } else if (Trigger.isAfter) {
        if (Trigger.isInsert) {
            handler.afterInsert(Trigger.new);
        }
    }
}

public class OpportunityTriggerHandler {
    public void beforeInsertOrUpdate(List<Opportunity> opps, Boolean isInsert) {
        Set<Id> userIds = new Set<Id>();
        Set<Id> recordTypeIds = new Set<Id>();
        Set<Id> accountIds = new Set<Id>();
        Set<Id> dealIds = new Set<Id>();

        for (Opportunity opp : opps) {
            if (opp.OwnerId != null) userIds.add(opp.OwnerId);
            if (isInsert) {
                if (opp.CreatedById != null) userIds.add(opp.CreatedById);
            } else {
                if (opp.LastModifiedById != null) userIds.add(opp.LastModifiedById);
            }
            if (opp.RecordTypeId != null) recordTypeIds.add(opp.RecordTypeId);
            if (opp.AccountId != null) accountIds.add(opp.AccountId);
            if (opp.Deal__c != null) dealIds.add(opp.Deal__c);
        }

        Map<Id, User> users = userIds.isEmpty() ? new Map<Id, User>() : new Map<Id, User>([SELECT Id, Name FROM User WHERE Id IN :userIds]);
        Map<Id, RecordType> recordTypes = recordTypeIds.isEmpty() ? new Map<Id, RecordType>() : new Map<Id, RecordType>([SELECT Id, Name FROM RecordType WHERE Id IN :recordTypeIds]);
        Map<Id, Account> accounts = accountIds.isEmpty() ? new Map<Id, Account>() : new Map<Id, Account>([SELECT Id, Name FROM Account WHERE Id IN :accountIds]);
        Map<Id, CustomObject__c> deals = dealIds.isEmpty() ? new Map<Id, CustomObject__c>() : new Map<Id, CustomObject__c>([SELECT Id, Name FROM CustomObject__c WHERE Id IN :dealIds]);

        for (Opportunity opp : opps) {
            if (opp.OwnerId != null && users.containsKey(opp.OwnerId)) {
                opp.Owner_Name__c = users.get(opp.OwnerId).Name;
            }
            if (isInsert && opp.CreatedById != null && users.containsKey(opp.CreatedById)) {
                opp.Created_By_Name__c = users.get(opp.CreatedById).Name;
            }
            if (!isInsert && opp.LastModifiedById != null && users.containsKey(opp.LastModifiedById)) {
                opp.Last_Modified_By_Name__c = users.get(opp.LastModifiedById).Name;
            }
            if (opp.RecordTypeId != null && recordTypes.containsKey(opp.RecordTypeId)) {
                opp.Record_Type_Name__c = recordTypes.get(opp.RecordTypeId).Name;
            }
            if (opp.AccountId != null && accounts.containsKey(opp.AccountId)) {
                opp.Account_Name__c = accounts.get(opp.AccountId).Name;
            }
            if (opp.Deal__c != null && deals.containsKey(opp.Deal__c)) {
                opp.Deal_Name__c = deals.get(opp.Deal__c).Name;
            }
        }
    }

    public void afterInsert(List<Opportunity> opps) {
        Set<Id> userIds = new Set<Id>();
        for (Opportunity opp : opps) {
            if (opp.CreatedById != null) userIds.add(opp.CreatedById);
            if (opp.LastModifiedById != null) userIds.add(opp.LastModifiedById);
        }

        Map<Id, User> users = userIds.isEmpty() ? new Map<Id, User>() : new Map<Id, User>([SELECT Id, Name FROM User WHERE Id IN :userIds]);

        List<Opportunity> oppsToUpdate = new List<Opportunity>();
        for (Opportunity opp : opps) {
            Boolean needsUpdate = false;
            Opportunity oppToUpdate = new Opportunity(Id = opp.Id);

            if (opp.CreatedById != null && users.containsKey(opp.CreatedById)) {
                oppToUpdate.Created_By_Name__c = users.get(opp.CreatedById).Name;
                needsUpdate = true;
            }
            if (opp.LastModifiedById != null && users.containsKey(opp.LastModifiedById)) {
                oppToUpdate.Last_Modified_By_Name__c = users.get(opp.LastModifiedById).Name;
                needsUpdate = true;
            }

            if (needsUpdate) {
                oppsToUpdate.add(oppToUpdate);
            }
        }

        if (!oppsToUpdate.isEmpty()) {
            update oppsToUpdate;
        }
    }
}


$proxyUrl = "http://userproxy.net:8080"
$testUrl = "https://test.salesforce.com"
$hostname = "test.salesforce.com"

# Test DNS resolution
$dnsTest = Test-NetConnection -ComputerName $hostname

if ($dnsTest.DnsResolved) {
    Write-Output "DNS resolution successful: $($dnsTest.DnsName)"
} else {
    Write-Output "DNS resolution failed for $hostname"
}

# Test web request through proxy
try {
    $webRequest = Invoke-WebRequest -Uri $testUrl -Proxy $proxyUrl -UseBasicParsing
    Write-Output "Successfully connected to $testUrl through proxy $proxyUrl"
    Write-Output "Status Code: $($webRequest.StatusCode)"
} catch {
    Write-Output "Error connecting to $testUrl through proxy $proxyUrl"
    Write-Output $_.Exception.Message
}


# Import necessary .NET types
Add-Type -TypeDefinition @"
using System.Net;
using System.Net.Http;
using System.Security.Authentication;
public class HttpClientHelper
{
    public static HttpClient CreateHttpClient(string proxyUrl)
    {
        var handler = new HttpClientHandler
        {
            UseProxy = true,
            Proxy = new WebProxy(proxyUrl),
            UseDefaultCredentials = false,
            SslProtocols = SslProtocols.Tls12
        };
        
        return new HttpClient(handler);
    }
}
"@

# Define proxy URL and test URL
$proxyUrl = "http://userproxy.net:8080"
$testUrl = "https://test.salesforce.com"

# Create HttpClient with the specified proxy and TLS 1.2
$httpClient = [HttpClientHelper]::CreateHttpClient($proxyUrl)

try {
    # Send a GET request
    $response = $httpClient.GetAsync($testUrl).Result
    if ($response.IsSuccessStatusCode) {
        Write-Output "Successfully connected to $testUrl through proxy $proxyUrl using TLS 1.2"
        Write-Output "Status Code: $($response.StatusCode)"
    } else {
        Write-Output "Failed to connect to $testUrl"
        Write-Output "Status Code: $($response.StatusCode)"
    }
} catch {
    Write-Output "Error connecting to $testUrl through proxy $proxyUrl using TLS 1.2"
    Write-Output $_.Exception.Message
}



# Load the required .NET assembly for HttpClient
Add-Type -AssemblyName "System.Net.Http"

# Define a helper class for creating HttpClient with SocketsHttpHandler and proxy configuration
Add-Type -TypeDefinition @"
using System;
using System.Net;
using System.Net.Http;
using System.Net.Sockets;
using System.Threading.Tasks;

public class HttpClientHelper
{
    public static HttpClient CreateHttpClient(string proxyUrl, string proxyUser, string proxyPassword)
    {
        var handler = new SocketsHttpHandler
        {
            UseProxy = true,
            Proxy = new WebProxy(new Uri(proxyUrl))
            {
                BypassProxyOnLocal = false,
                UseDefaultCredentials = false,
                Credentials = new NetworkCredential(proxyUser, proxyPassword)
            },
            SslOptions = 
            {
                EnabledSslProtocols = System.Security.Authentication.SslProtocols.Tls12
            },
            ConnectCallback = async (context, token) =>
            {
                var proxyUri = new Uri(proxyUrl);
                var proxyConnection = new Socket(SocketType.Stream, ProtocolType.Tcp);
                await proxyConnection.ConnectAsync(proxyUri.Host, proxyUri.Port);

                var stream = new NetworkStream(proxyConnection, ownsSocket: true);
                return stream;
            }
        };

        return new HttpClient(handler);
    }
}
"@ -ReferencedAssemblies @("System.Net.Http.dll", "System.dll", "System.Net.dll", "System.Security.dll")

# Define proxy URL, user, password, and test URL
$proxyUrl = "http://userproxy.net:8080"
$proxyUser = "proxyUser"
$proxyPassword = "proxyPassword"
$testUrl = "https://test.salesforce.com"

# Create HttpClient with the specified proxy and TLS 1.2
$httpClient = [HttpClientHelper]::CreateHttpClient($proxyUrl, $proxyUser, $proxyPassword)

try {
    # Send a GET request
    $response = $httpClient.GetAsync($testUrl).Result
    if ($response.IsSuccessStatusCode) {
        Write-Output "Successfully connected to $testUrl through proxy $proxyUrl using TLS 1.2"
        Write-Output "Status Code: $($response.StatusCode)"
    } else {
        Write-Output "Failed to connect to $testUrl"
        Write-Output "Status Code: $($response.StatusCode)"
    }
} catch {
    Write-Output "Error connecting to $testUrl through proxy $proxyUrl using TLS 1.2"
    Write-Output $_.Exception.Message
    if ($_.Exception.InnerException) {
        Write-Output "Inner Exception: $($_.Exception.InnerException.Message)"
    }
}



1. Objective
Develop a service to ingest and process feeds from SalesForce into the system.
2. Requirements
Data Retrieval: Fetch feed data from SalesForce at regular intervals.
Authentication: Implement secure authentication to connect with SalesForce API.
Data Transformation: Transform the raw feed data into the required format.
Error Handling: Implement robust error handling for data retrieval and transformation processes.
Logging: Maintain logs for data fetching, transformation, and ingestion activities.
Scalability: Ensure the service can handle large volumes of data efficiently.
Testing: Implement unit and integration tests for the service.
3. Technical Specifications
Programming Language: Preferably Java or Python.
Frameworks/Libraries: Use appropriate libraries for API integration, data transformation, and testing.
SalesForce API: Utilize SalesForce REST API for data retrieval.
Database: Ensure compatibility with the existing database system for data storage.
Deployment: Configure deployment pipelines for continuous integration and deployment.
4. Development Tasks
Task 1: Set up project structure and configure SalesForce API integration.
Task 2: Implement data retrieval logic from SalesForce.
Task 3: Develop data transformation modules.
Task 4: Integrate error handling and logging mechanisms.
Task 5: Write unit tests for individual components.
Task 6: Perform integration testing with the complete workflow.
Task 7: Optimize the service for performance and scalability.
Task 8: Prepare deployment scripts and documentation.
5. Acceptance Criteria
Functionality: The service successfully retrieves, transforms, and ingests feed data from SalesForce.
Error Management: Proper error handling and logging are in place.
Performance: The service performs efficiently under expected data loads.
Testing: All unit and integration tests pass successfully.
Documentation: Comprehensive documentation for setup, usage, and maintenance is provided.
6. Dependencies
SalesForce API Access: Ensure API access and credentials are available.
Database Access: Ensure access to the database for data storage and retrieval.
Development Environment: Set up development and testing environments.
7. Timeline
Week 1: Project setup, API integration, and initial data retrieval logic.
Week 2: Data transformation and error handling.
Week 3: Logging implementation and unit testing.
Week 4: Integration testing, performance optimization, and documentation.
Week 5: Deployment and final review.
8. Risks and Mitigation
API Rate Limits: Implement retry mechanisms and optimize data fetch intervals.
Data Inconsistency: Validate data integrity during transformation.
System Performance: Conduct load testing and optimize code for high performance.
9. Stakeholders
Product Owner: Oversees the project and ensures alignment with business goals.
Development Team: Responsible for implementing the service.
QA Team: Conducts testing to ensure quality and reliability.
DevOps Team: Manages deployment and continuous integration processes.
This structured approach ensures clear objectives, detailed tasks, and measurable acceptance criteria for developing the SalesForce Feed Ingestor Service.
